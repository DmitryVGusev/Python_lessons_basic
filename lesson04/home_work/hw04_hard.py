# Задание-1:
# Матрицы в питоне реализуются в виде вложенных списков:
# Пример. Дано:
matrix = [[1, 0, 8],
          [3, 4, 1],
          [0, 4, 2]]
          
# Выполнить поворот (транспонирование) матрицы
# Пример. Результат:
# matrix_rotate = [[1, 3, 0],
#                  [0, 4, 4],
#                  [8, 1, 2]]

# Суть сложности hard: Решите задачу в одну строку


def transporate(matrix):
    """
    Транспонирует матрицу
    :param matrix: матрица формата список вложенных списков
    :return: матрица формата список вложенных списков
    """
    return list(map(list, zip(*matrix)))


# Проверка результатов
print(transporate(matrix))

# Задание-2:
# Найдите наибольшее произведение пяти последовательных цифр в 1000-значном числе.
# Выведите произведение и индекс смещения первого числа последовательных 5-ти цифр.
# Пример 1000-значного числа:
number = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"""

from functools import reduce




def get_top_five_mult(num: str):
    """
    Находит наибольшее произведение пяти последовательных цифр в числе
    :param num: Многозначное число (>=5) в формате строки
    :return: Пара (ключь, значение) индекс последовательности и произведение.
    None при некорректности входных данных
    """
    def get_five_nums_multiplied(line, ind):
        """Возвращает произведение пяти чисел из списка начиная с заданного индекса"""
        return reduce((lambda x, y: x * y), [int(line[i]) for i in range(ind, ind+5)])

    # Выходим из функции если на вход не число или число менее 5 знаков
    if not num.isdigit() or len(num) < 5:
        return None

    # Проходим по всему списку и получаем пары [стартИндекс, произведение]
    result_all = []
    for i in range(len(num)-4):
        result_all.append([i, get_five_nums_multiplied(num, i)])

    # Находим пару с максимальным произведением
    result = max(result_all, key=lambda item: item[1])
    return f"{result[1]}, {result[0]}"


# Проверка результатов
# Избавляемся от переноса строк в числе-примере
number = number.replace('\n', '')

print(get_top_five_mult(number))  # 40824, 364
print(get_top_five_mult("12345"))  # 120, 0
print(get_top_five_mult("123not_digit456"))  # None
print(get_top_five_mult("123"))  # None


# Задание-3 (Ферзи):
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били
# друг друга. Вам дана расстановка 8 ферзей на доске.
# Определите, есть ли среди них пара бьющих друг друга.
# Программа получает на вход восемь пар чисел,
# каждое число от 1 до 8 — координаты 8 ферзей.
# Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.


def is_correct_position(coords: list):
    """
    Проверяет возможность нахождения 8ми ферзей на одной доске 8х8.
    Фактически, проверяет что на каждой строке и столбце одновременно находится лишь одна фигура
    :param coords: Список списков из двух целых
    :return: 'NO' Если ферзи не бьют друг друга, иначе 'YES', 'ERROR' если входные параметры некорректны
    """

    # Попарно сравниваем координаты каждого ферзя
    for i in range(8):
        for j in range(i+1, 8):
            # Если входные параметры некорректны то возвращаем ошибку
            try:
                # Если совподают оси Х, Y или диагонали то значит ферзи бьют друг друга
                if coords[i][0] == coords[j][0] \
                        or coords[i][1] == coords[j][1] \
                        or abs(coords[i][0] - coords[j][0]) == abs(coords[i][1] - coords[j][1]):
                    return 'YES'
            except:
                return 'ERROR'
    # Ферзи не бют друг друга
    return 'NO'


# Проверка результатов
coords = [
    [1, 0],
    [6, 1],
    [4, 2],
    [7, 3],
    [0, 4],
    [3, 5],
    [5, 6],
    [2, 7]
]  # Корректная расстановка
print(is_correct_position(coords))  # NO

from random import randint
random_coords = [[randint(0, 7), randint(0, 7)] for _ in range(8)]
print(is_correct_position(random_coords))  # YES

print(is_correct_position([]))  # ERROR
