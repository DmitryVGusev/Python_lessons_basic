# Задание-1:
# Напишите функцию, округляющую полученное произвольное десятичное число
# до кол-ва знаков (кол-во знаков передается вторым аргументом).
# Округление должно происходить по математическим правилам (0.6 --> 1, 0.4 --> 0).
# Для решения задачи не используйте встроенные функции и функции из модуля math.
"""
На поверку, оказалось самым сложным заданием для меня из всех задач вообще(в том числе и hard)
Оригинальный round работает даже с отрицательными количеством знаков. Его я реализовать не смог.
Данная задача отличается тем, что стандартные операции округления работают по принципу  >= 0.5 >
Тут же, в случае 0.5 требуется брать следующее число на сравнение.
"""

def my_round(number: float, ndigits: int=1):
    """
    Функция, округляющаяя полученное произвольное десятичное число до заданного количества знаков.
    Будем считать, что количество знаков после запятой - положительное число больше 1
    Также, считаем что произвольное число положительное
    :param number: число типа float
    :param ndigits: количество знаков после запятой
    :return: округленное число типа float
    """
    def check_next_num(string: str, ind: int):
        """
        Функия смотрит на заданный индекс строки.
        Округление считается по математическим правилам (0.6 --> 1, 0.4 --> 0).
        Если число по индексу == 5 то берется следующее.
        Возвращает True если округлять нужно в большую сторону.
        :param string: строка с записанным числом
        :param ind: индекс, с которого начинается проверка
        :return:
        """
        for i in range(ind, len(string)):
            if string[i] > '5':
                return True
            elif string[i] < '5':
                return False

    # Проверка что заданное количество знаков после запятой более 1
    # И заданное число положительное
    if ndigits < 1 or number < 0:
        return None

    # Переводим число строку
    str_number = str(number)
    # Находим положение точки
    last_ind = ndigits + str_number.find(".")

    # Если заданное количество после запятой больше самого количества, то возвращаем число в изначальном виде
    if len(str_number) <= last_ind + 1:
        return number

    if check_next_num(str_number, last_ind + 1):
        result = float(str_number[:last_ind+1]) + (10 ** -(ndigits))
    else:
        result = float(str_number[:last_ind+1])

    return result


print(my_round(2.1265, 0))  # None
print(my_round(2.1255, 15))  # 2.1255
print(my_round(2.1234567, 5))
print(my_round(2.1999967, 5))
print(my_round(2.9999967, 5))


# Задание-2:
# Дан шестизначный номер билета. Определить, является ли билет счастливым.
# Решение реализовать в виде функции.
# Билет считается счастливым, если сумма его первых и последних цифр равны.
# !!!P.S.: функция не должна НИЧЕГО print'ить

def lucky_ticket(ticket_number: int):
    """
    Функция определяющая является ли шестизначный номер билета счастливым.
    Билет считается счастливым если суммы первых и последних цифр равны
    :param ticket_number: Целое шестизначное число
    :return: boolean
    """

    # Переведем число в строку
    str_number = str(ticket_number)

    # Проверка если число не шестизначное
    if len(str_number) != 6:
        return False

    # При помощи функции map переводим символы строки в числа и суммируем. Далее, сравниваем суммы
    if sum(map(int, str_number[0:3])) == sum(map(int, str_number[3:])):
        return True
    else:
        return False


print(lucky_ticket(123006))
print(lucky_ticket(12321))
print(lucky_ticket(436751))
