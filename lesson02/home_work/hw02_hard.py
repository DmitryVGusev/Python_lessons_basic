# Задание-1: уравнение прямой вида y = kx + b задано в виде строки.
# Определить координату y точки с заданной координатой x.

equation = 'y = -12x + 11111140.2121'
x = 2.5
# вычислите и выведите y

# Не будем полагаться на одиночное количество пробелов и удалим их из строки
equation = equation.replace(' ', '')
# Определим положение опорных знаков: '=' и '+'. От них будем делать срезы.
position_equal = equation.find('=')
position_plus = equation.find('+')

# Вычисляем k и b по срезам
k = float(equation[position_equal + 1:position_plus - 1])
b = float(equation[position_plus + 1:])

# Вычисляем y и выводим
y = k * x + b
print(y)

# Задание-2: Дата задана в виде строки формата 'dd.mm.yyyy'.
# Проверить, корректно ли введена дата. (Проверю. А вывод проверки?)
# Условия корректности:
# 1. День должен приводиться к целому числу в диапазоне от 1 до 30(31)
#  (в зависимости от месяца, февраль не учитываем)
# 2. Месяц должен приводиться к целому числу в диапазоне от 1 до 12
# 3. Год должен приводиться к целому положительному числу в диапазоне от 1 до 9999
# 4. Длина исходной строки для частей должна быть в соответствии с форматом 
#  (т.е. 2 символа для дня, 2 - для месяца, 4 - для года)

# Пример корректной даты
date = '01.11.1985'

# Примеры некорректных дат
date = '01.22.1001'
date = '1.12.1001'
date = '-2.10.3001'


# Для удобства оберну логику в функцию. По сути, заменяем многовложенными if'ами
def is_currect_date(date: str):
    """Функция возращает True если запись даты корректна, и False если нет"""

    # Проверяем длину записи
    if len(date) != 10:
        return False

    # Мы уже прошли списки и строки, а значит можем пользоваться методом строки .split()
    # Запишем дату в список поэлементно [день, месяц, год]
    date_list = date.split('.')

    # Проверяем количество частей даты и их формат
    if len(date_list) != 3:
        return False
    elif len(date_list[0]) != 2 or len(date_list[1]) != 2 or len(date_list[2]) != 4:
        return False

    # Переводим элементы списка в целые числа
    day = int(date_list[0])
    month = int(date_list[1])
    year = int(date_list[2])

    # Проверяем валидность года
    if year < 1 or year > 9999:
        return False

    # Проверяем валидность месяца
    if month < 1 or month > 12:
        return False

    # Подсчитываем количество дней в месяце (считаем февраль за 30)
    if month % 2 == 0:
        days_in_month = 31
    else:
        days_in_month = 30

    # Проверяем валидность дня
    if day < 1 or day > days_in_month:
        return False

    # Возвращаем True так как все условия корректности соблюдены
    return True


# Вывод проверки
if is_currect_date(date):
    print("Дата корректна")
else:
    print("Дата некорректна")

# Задание-3: "Перевёрнутая башня" (Задача олимпиадного уровня)
#
# Вавилонцы решили построить удивительную башню —
# расширяющуюся к верху и содержащую бесконечное число этажей и комнат.
# Она устроена следующим образом — на первом этаже одна комната,
# затем идет два этажа, на каждом из которых по две комнаты, 
# затем идёт три этажа, на каждом из которых по три комнаты и так далее:
#         ...
#     12  13  14
#     9   10  11
#     6   7   8
#       4   5
#       2   3
#         1
#
# Эту башню решили оборудовать лифтом --- и вот задача:
# нужно научиться по номеру комнаты определять,
# на каком этаже она находится и какая она по счету слева на этом этаже.
#
# Входные данные: В первой строчке задан номер комнаты N, 1 ≤ N ≤ 2 000 000 000.
#
# Выходные данные:  Два целых числа — номер этажа и порядковый номер слева на этаже.
#
# Пример:
# Вход: 13
# Выход: 6 2
#
# Вход: 11
# Выход: 5 3


def room_adress(num: int):
    """
    Функция находит и выводит адрес комнаты в Вавилонской башне (этаж, порядковый_номер)
    Логика построена на основе компьютерной игры:
    Уровень - это двумерный массив Вавилонской башни где количество этажей равно количеству номеров на этаже
    Этаж - строка массива
    Шаг - смещение по этажу
    При задании номера комнаты мы фактически генерируем иргу: как только уровень пройден - генерируется новый уровень
     с размером +1
    А метод решения задачи - подниматься пешком проходя каждый номер до тех пор, пока не встретим конкретный
    """

    # Проверка на валидность входных данных. Положим, что на вход подается целое число
    if num < 1 or num > 2000000000:
        return "Not in range"

    # Абсолютные координаты нахождения точки в данный момент
    abs_num = 0
    abs_x = 0
    abs_y = 0

    # Координаты положения точки относительно текущего уровня
    current_x = 0
    current_y = 0

    # Размерность уровня
    level_size = 0

    # Цикл до тех пор, пока текущий номер не равен заданному
    while abs_num != num:
        """
        Проверяем, прошли ли мы уровень.
        Если прошли, отрисовываем новый и встаем в начало.
        """
        if current_y == level_size and current_x == level_size:
            level_size += 1
            current_x = 1
            current_y = 1
            abs_x = 1
            abs_y += 1
            abs_num += 1
            continue

        """
        Проверяем, прошли ли мы этаж.
        Если прошли, встаем на следующий.
        """
        if current_x == level_size:
            current_y += 1
            current_x = 1
            abs_x = 1
            abs_y += 1
            abs_num += 1
            continue

        """Делаем шаг"""
        current_x += 1
        abs_x += 1
        abs_num += 1

    #  Вывод функции: этаж, порядковый_номер
    print("{} {}".format(abs_y, abs_x))


# Пример вызова функции
room_adress(157)







